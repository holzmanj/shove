-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParSperg where
import qualified AbsSperg
import LexSperg
}

%name pListStmt ListStmt
%name pStmt Stmt
%name pExpr10 Expr10
%name pExpr9 Expr9
%name pExpr8 Expr8
%name pExpr7 Expr7
%name pExpr6 Expr6
%name pExpr5 Expr5
%name pExpr4 Expr4
%name pExpr3 Expr3
%name pExpr2 Expr2
%name pExpr1 Expr1
%name pExpr Expr
%name pLit Lit
%name pListElem ListElem
%name pElem Elem
%name pListParam ListParam
%name pParam Param
-- no lexer declaration
%monad { Either String } { (>>=) } { return }
%tokentype {Token}
%token
  '!' { PT _ (TS _ 1) }
  '!=' { PT _ (TS _ 2) }
  '%' { PT _ (TS _ 3) }
  '(' { PT _ (TS _ 4) }
  ')' { PT _ (TS _ 5) }
  '*' { PT _ (TS _ 6) }
  '+' { PT _ (TS _ 7) }
  ',' { PT _ (TS _ 8) }
  '-' { PT _ (TS _ 9) }
  '->' { PT _ (TS _ 10) }
  '/' { PT _ (TS _ 11) }
  '::' { PT _ (TS _ 12) }
  ';' { PT _ (TS _ 13) }
  '<' { PT _ (TS _ 14) }
  '<=' { PT _ (TS _ 15) }
  '=' { PT _ (TS _ 16) }
  '==' { PT _ (TS _ 17) }
  '>' { PT _ (TS _ 18) }
  '>=' { PT _ (TS _ 19) }
  '[' { PT _ (TS _ 20) }
  ']' { PT _ (TS _ 21) }
  'and' { PT _ (TS _ 22) }
  'else' { PT _ (TS _ 23) }
  'false' { PT _ (TS _ 24) }
  'if' { PT _ (TS _ 25) }
  'let' { PT _ (TS _ 26) }
  'or' { PT _ (TS _ 27) }
  'then' { PT _ (TS _ 28) }
  'true' { PT _ (TS _ 29) }
  'void' { PT _ (TS _ 30) }
  '{' { PT _ (TS _ 31) }
  '|' { PT _ (TS _ 32) }
  '}' { PT _ (TS _ 33) }
  L_Ident  { PT _ (TV $$) }
  L_integ  { PT _ (TI $$) }
  L_doubl  { PT _ (TD $$) }
  L_charac { PT _ (TC $$) }
  L_quoted { PT _ (TL $$) }

%%

Ident :: { AbsSperg.Ident}
Ident  : L_Ident { AbsSperg.Ident $1 }

Integer :: { Integer }
Integer  : L_integ  { (read ($1)) :: Integer }

Double  :: { Double }
Double   : L_doubl  { (read ($1)) :: Double }

Char    :: { Char }
Char     : L_charac { (read ($1)) :: Char }

String  :: { String }
String   : L_quoted { $1 }

ListStmt :: { [AbsSperg.Stmt] }
ListStmt : {- empty -} { [] }
         | Stmt ListStmt { (:) $1 $2 }
         | {- empty -} { [] }
         | Stmt { (:[]) $1 }
         | Stmt ';' ListStmt { (:) $1 $3 }

Stmt :: { AbsSperg.Stmt }
Stmt : 'let' Ident '=' Expr { AbsSperg.SBind $2 $4 }
     | Expr { AbsSperg.SEval $1 }

Expr10 :: { AbsSperg.Expr }
Expr10 : Ident { AbsSperg.EIdent $1 } | Lit { AbsSperg.ELit $1 }

Expr9 :: { AbsSperg.Expr }
Expr9 : Expr9 Expr10 { AbsSperg.EApply $1 $2 }
      | '(' Expr ')' { $2 }

Expr8 :: { AbsSperg.Expr }
Expr8 : '!' Expr9 { AbsSperg.ETrigger $2 } | Expr9 { $1 }

Expr7 :: { AbsSperg.Expr }
Expr7 : Expr7 '*' Expr8 { AbsSperg.EMul $1 $3 }
      | Expr7 '/' Expr8 { AbsSperg.EDiv $1 $3 }
      | Expr7 '%' Expr8 { AbsSperg.EMod $1 $3 }
      | Expr8 { $1 }

Expr6 :: { AbsSperg.Expr }
Expr6 : Expr6 '+' Expr7 { AbsSperg.EAdd $1 $3 }
      | Expr6 '-' Expr7 { AbsSperg.ESub $1 $3 }
      | Expr7 { $1 }

Expr5 :: { AbsSperg.Expr }
Expr5 : Expr6 '::' Expr5 { AbsSperg.ECons $1 $3 } | Expr6 { $1 }

Expr4 :: { AbsSperg.Expr }
Expr4 : Expr5 '<' Expr5 { AbsSperg.ELess $1 $3 }
      | Expr5 '>' Expr5 { AbsSperg.EMore $1 $3 }
      | Expr5 '<=' Expr5 { AbsSperg.ELessEq $1 $3 }
      | Expr5 '>=' Expr5 { AbsSperg.EMoreEq $1 $3 }
      | Expr5 '==' Expr5 { AbsSperg.EEqual $1 $3 }
      | Expr5 '!=' Expr5 { AbsSperg.ENEqual $1 $3 }
      | Expr5 { $1 }

Expr3 :: { AbsSperg.Expr }
Expr3 : Expr4 'and' Expr3 { AbsSperg.EAnd $1 $3 } | Expr4 { $1 }

Expr2 :: { AbsSperg.Expr }
Expr2 : Expr3 'or' Expr2 { AbsSperg.EOr $1 $3 } | Expr3 { $1 }

Expr1 :: { AbsSperg.Expr }
Expr1 : Expr1 '->' Expr2 { AbsSperg.ESend $1 $3 } | Expr2 { $1 }

Expr :: { AbsSperg.Expr }
Expr : 'if' Expr 'then' Expr 'else' Expr { AbsSperg.EIfThen $2 $4 $6 }
     | Expr1 { $1 }

Lit :: { AbsSperg.Lit }
Lit : Integer { AbsSperg.LInt $1 }
    | Double { AbsSperg.LDouble $1 }
    | Char { AbsSperg.LChar $1 }
    | String { AbsSperg.LString $1 }
    | 'true' { AbsSperg.LTrue }
    | 'false' { AbsSperg.LFalse }
    | 'void' { AbsSperg.LVoid }
    | '[' ListElem ']' { AbsSperg.LList $2 }
    | '{' ListParam '|' ListStmt '}' { AbsSperg.LLambda $2 $4 }

ListElem :: { [AbsSperg.Elem] }
ListElem : {- empty -} { [] }
         | Elem { (:[]) $1 }
         | Elem ',' ListElem { (:) $1 $3 }

Elem :: { AbsSperg.Elem }
Elem : Expr { AbsSperg.Elem $1 }

ListParam :: { [AbsSperg.Param] }
ListParam : {- empty -} { [] }
          | Param { (:[]) $1 }
          | Param ',' ListParam { (:) $1 $3 }

Param :: { AbsSperg.Param }
Param : Ident { AbsSperg.Param $1 }
{

happyError :: [Token] -> Either String a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer = tokens
}

